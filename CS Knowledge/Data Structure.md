<br/>

- 참고자료

    [자료구조 정의와 왜 중요한지 참고](https://hanamon.kr/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0/)

    [노마드코더 자료구조와 알고리즘](https://youtu.be/NFETSCJON2M)

    [자료구조: Linked List 대 ArrayList](https://www.nextree.co.kr/p6506/)
    
    [Linked List(연결리스트) 의 개념과 구현](https://s-realstory.tistory.com/51)

<br/>

# 자료 구조 

- 자료 구조와 알고리즘을 모르는데 개발 최적화를 논하는 건 어불성설이라는 것이 점점 느껴진다 
- 일단 자료구조라는게 왜 필요한지, 어떻게 쓰라고 만들어진것인지 하나씩 정리하고 알고리즘을 공부해보면 좋을듯

<br/>

**자료구조란?**
- 자료구조는 특정 형태의 여러 데이터를 저장하고, 사용하는 방법이 정의된 것이다.
- 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미 - [위키피디아](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)

<br/>

**그래서?**
- 데이터를 체계적으로 저장하고, 또 효율적으로 활용하기 위해 사용할 수 있다. 
- 특정 목적에 맞게 제대로 활용하는 경우, 획기적으로 작업 효율을 올릴 수 있다.
    - 여기서 작업 효율이란?
    - 자료구조 속의 데이터를 **읽고 / 검색하고 / 추가하고 /삭제하는** 행위가 얼마나 효율적인지를 말한다.

<br/>


**효율성의 척도, 시간 복잡도**
- Time Complexity
- 자료구조나 알고리즘이 얼마나 빠르고 느린지 측정하는 방법
- 실제 시간을 측정하는 것이 X
- 얼마나 많은 단계를 거쳐야 하는가를 판단하는 것
- 단계가 적을수록 좋다!

---
<br/>

**배열**
- 고정된 크기를 갖는다. 선언 시 얼마만큼의 크기로 만들 것인지 미리 정해야 함
- 나중에 데이터를 덜 집어넣거나 삭제하더라도 차지하는 공간은 그대로다 <- 비효율적임
- 자료들이 연속적인 형태로 구성되어 있다. 
    - 각 데이터는 인덱스 번호를 가진다 
- **읽기**
    - 인덱스를 통해 random access가 가능해서 빠르다.
        - 인덱스를 통한다면 값 조회, 수정이 매우 빠름
        - 배열 크기가 얼마나 크던 아무 상관 없이 1단계만 통하면 되고, 이것을 시간복잡도 O(1)이라고 함
- **검색**
    - 인덱스는 알지만 안에 담긴 내용은 모름
    - 선형 검색 = 처음부터 순차적으로 열어봐야 함 
    - 배열의 크기에 비례해서 오래 걸릴 가능성이 많음. 운이 좋다면 일찍 찾겠지만 
- **추가**
    - 정해진 크기 안에서 집어넣어야 하므로 골치 아프다.
    - 비어있는 끝칸이 있다면 제일 좋겠지만
    - 중간이라면 다른 애들을 옆으로 한 칸씩 밀고 들어가야 하고 (으악)
    - 맨 처음에 넣겠다면 나머지 모든 애들을 한칸씩 밀고 들어가야 하고 (웩)
    - 공간이 부족하면? 더 큰 배열을 생성하고 내용을 복사한 뒤 빈칸에 넣어야... :s
- **삭제**
    - 추가와 똑같이 골치아프다. 배열 중간에는 공백이 있을수 없어!!
    - 맨 앞에 친구를 지우면 나머지 모든 친구를 다 밀어야 한다...하지만 배열이 만개짜리라면?:grimacing:

<br/>

**리스트**
- 배열의 고정 사이즈 문제를 해결하기 위해 등장 -> **사이즈가 동적**이다
- 순서가 있는 데이터의 모임으로 시퀀스라고도 한다. 

    - arrayList
        - 리스트의 동적 사이징 + 배열의 인덱스를 통한 랜덤 액세스
        - 조회는 매우 빠르고 / 검색과 추가 삭제는 조금 골치아픈 배열의 장단점을 그대로 가진다
        - 메모리상 데이터가 근처에 묶여있기 때문에 산발적으로 저장되는 자료구조들보다는 데이터 검색이 수월하다  
    - linkedList
        - 노드 = 데이터 + 포인터
            
            저장되는 데이터들이 각자 다음 녀석이 뭔지 알고 있는 자료구조
        - 추가삭제 시 전체 데이터를 밀고 땡기고 해야 하는 배열과 다르게, 그 주변 데이터의 참조값만 바꾸면 되므로 추가 삭제가 비교적 빠르다   
        - **검색** 
            - 원하는 게 나올때까지 순서대로 찾아야 한다.
            - arrayList나 배열과 달리 메모리상 데이터들이 모여있지 않고 다음 것의 주소를 참조하기 때문에 시간이 더 오래 걸린다. 
        **추가 / 삭제**
            - 맨 처음에 추가 삭제 : O(1)
            - 맨 끝에 추가 삭제
                
                맨 끝 요소가 뭔지 안다면 O(1)
                
                모르면 O(n) -> 끝 요소가 나올때까지 찾아간 뒤 작업해야 함
            - 중간에 추가삭제 : 검색 시간 + O(1)
        - 근데 유스케이스가..?
            - 작업 큐를 관리할 때. 넣고 / 삭제하고가 많은 작업에 유리하므로 
            - 방문한 웹 페이지 리스트
            - 음악 스트리밍 목록 등 
    