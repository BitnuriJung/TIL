<br/>

# 전략패턴 (Strategy Pattern)

## 느낀점
- 너무 재밌다. 클린 아키텍쳐에서 아는척하고 넘어갔지만 사실 애매모호했던 인터페이스 사용법을 구체적 예시로 보여주니까 속이 다 시원했다.
- 객체, 객체 지향, 객체 지향의 원칙에 대해서 나름의 정리를 내리고 정리해서 말할 수 있어야겠다. 클래스와 객체도 제대로 구분하지 못하고 있었음
- ‘구성’ 이라는 용어는 처음 봤다. 상속이 아니라 구성이라는 개념이 신선했음.  (구성은 의존성인가??)

- 디자인 패턴은 객체지향 원칙들을 잘 반영하여 **변화**에 유연하게 대처할 수 있도록 한 것들이다.

<br/><br/>

## 정리

`변화하는 부분은 분리한다` 

> 객체가 선택할 수 있는 행동이 여러개일때, 이 행동을 포괄하는 상위 인터페이스를 만든다. 객체에서는 상위 인터페이스 형식을 따르기만 하면 여러 행동(전략)들을 동적으로 바꿔낄 수 있다.
> 

>strategy :<br/> 
A **strategy** is a general plan or **set of plans** intended to achieve something, especially over a long period.
<br/>어떤 목표를 이루기 위한 대체적인 계획이나 **일련의 계획**
<br/> 출처 : [콜린스코빌드 영영사전](https://www.collinsdictionary.com/dictionary/english)

<br/>

**[오늘의 예시] 여러 가지 방식으로 날아다닐 수 있는 오리를 생각해봅시다.** 

- 전략 : 객체가 취할 수 있는 일련의 행동
    - 오리가 ‘날개로 난다’ ‘로켓으로 날아간다’ ‘날지 않는다’ 등
    - 오리가 ‘꽥꽥거린다’ ‘울지 않는다’ ‘깍깍거린다’ 등
- 오리 객체에서 ‘변화할 수 있는 부분’인 전략들의 상위 인터페이스를 만든다.
    - `fly() 함수를 가진 Flyable 인터페이스`
    - `quack() 함수를 가진 Quackable 인터페이스`
- 오리 추상 클래스는 행동 인터페이스를 ‘가지고’ 있다. (=구성)
    - `Flyable flyable;`
- 오리 상속 구상 클래스들은 구체적으로 어떤 행동 클래스를 사용할 지 정한다. (생성자에서 새로 만들어도 되고, 외부에서 주입받을 수도 있다)
    - `flyable = new FlyWithWings();`
- 행동 인터페이스를 구현한 각각의 행동 클래스들은 반드시 서로 교환 가능해야 한다. (이게 LSP?) 따라서 오리객체가 동적으로 행동 클래스를 변경할 수 있다.
- 오리 상속 클래스들은 변화 가능한 행동 클래스의 구체적인 코드에 대해 전혀 신경쓸 필요가 없다. = 캡슐화
- 여기에서 행동을 취하는 것 = 전략을 선택하는 것. 그래서 전략패턴!!

<br/><br/>

# 위 내용을 이해하기 위해 추가로 공부한 것들

- 객체지향 원칙 (변화에 대처한다)
    - 추상화
        - 클래스
            - 추상적인 개념을 가진 클래스를 만들고, 구체적인 클래스가 이를 상속해서 객체를 만들어내도록 한다.
            - 인간이라고 한다면 이름, 키, 무게, 성별, 말하는 행위, 먹는 행위 등등 멤버 변수들과 멤버 함수들을 정의한다.
            - ‘인간’ 이라는 개념이 실제 돌아다니는 사람일수는 없다. 추상적인 개념일 뿐이다. 이 자체로 객체가 만들어지지 않고 반드시 상속을 통해 구체화 된 클래스가 객체를 만들어내도록 하는 것이 클래스에서의 추상화다.
            
            ⇒ 이를 통해 코드 재사용성을 높일 수 있다. 100 종류의 사람 객체를 만들기 위해 동일한 변수와 함수를 복붙할 필요가 없어지는 것이다. 
            
        - 함수
            - 클래스 혹은 인터페이스에서 슈퍼쪽이 자식쪽에게 특정 함수를 ‘반드시’ 바꿔서 사용하도록 강제할 수 있다.
            
            ⇒ 슈퍼쪽에서 만든 함수가 다양한 상황에 대처할 수 있는 함수가 된다. (오리가 날든가 안날든가) 
            
            ⇒ 상속받은 자식쪽이 특정 함수를 반드시 사용한다는 것을 알 수 있다. 
            
    - 캡슐화
        - 외부에서 건드려도 되는 것과 건드리면 안되는 것을 나눈다 (접근제어자 사용 private, public, protected) ⇒ 개발자의 실수를 줄인다.
        - 외부에서 신경써야 하는것과 신경쓰지 않아도 되는 것을 나눈다. Duck 객체는 Fly() 함수만 쓰면  될 뿐, 그 내부에 있는 구체적인 코드에 대해 신경쓰지 않아도 된다. ⇒ 책임 소재가 분명하고 코드 중복이 줄어든다. 재사용성은 높아진다. 유지보수가 훨씬 쉬워질 수 있다.
    - 상속
        - 클래스에 있는 변수, 함수를 객체에서 그대로 사용할 수 있다. ⇒ 코드 재사용성이 높아진다 (100마리의 동물 객체를 만들 때, 이름, 색상 등 같은 변수, 먹다 등의 같은 함수가 들어간 100개의 클래스를 만들 필요가 없어진다)
        - 오버라이딩, 오버로딩
            - 오버라이딩 : 슈퍼 클래스에 선언된 함수를 원하는 방식으로 덮어쓴다. 예를 들어 인사하기() 함수가 있다면 한국인 클래스는 ‘안녕하세요’를 말하도록, 미국인 클래스는 ‘How are you?’ 를 말하도록 할 수 있다.
            - 오버로딩 : 슈퍼 클래스에 선언된 함수가 다양한 매개변수를 받아서 다양한 처리를 할 수 있도록 한다.
    - 다형성
        - 여러 모양을 할 수 있다는 뜻이다. 하나의 타이틀을 가지고 있지만 여러가지 모양을 가질 수 있고 바꿔서 사용할 수 있다.
        - 함수의 다형성 → 추상 메서드를 통해 이룰 수 있다.
        - 인터페이스 구현체의 다형성
            
- 인터페이스
    - 추상클래스와 비슷하지만, 변수를 가질 수 없고 추상 메서드만 있어야 한다.