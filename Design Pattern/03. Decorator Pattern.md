<br/>

# 느낀점
- 정말 생각을 전혀 못한 패턴이었다. 생각해낸 사람 정말 대단한듯
- 이번 패턴부터는 정말 머리로만 이해하는 데 한계에 부딪혔다. 특히 super 클래스가 가진 변수나 함수를 가져다 쓰는 부분이나 추상 메소드 만드는 방식 등등. 까먹은 게 많았음. 오랜만에 자바 이클립스 켜서 하나씩 이해함.
    - 예) 131쪽에 Mocha 생성자에서 beverage 앞에 왜 this 여야할까? super 면 안될까?
    
- 첨가물을 아무리 더해도 음료라는 객체의 형식에 어떤 변화도 없다는 게 큰 장점같다.
- 이 패턴을 몰랐다면 첨가물은 완전히 다른 방식으로 구현했을 것 같다. 첨가물 인터페이스를 만들고 Beverage 가 첨가물 list 를 가지는 방식?
    - 문제점
        - 아무 첨가물 없는 음료도 첨가물 리스틀 가져야만 함.
        - ~~첨가물을 추가하는 코드가 한줄씩 더 길어질수밖에 없음.~~
        - 첨가물 코드 구현이 첨가물쪽이 아니라 음료쪽에 들어감. → 첨가물 구현 방식이 달라지는데 음료 코드를 수정해야 하는 문제 발생
- 133 페이지에서 enum Size 를 만들고 나니 자료형으로 Size를 쓸수 있게 되는 걸 보고 신기했음. 공부해야겠다.
    - 열거형 클래스. 타입을 내가 만들 수 있다.
    - 스위치문 걸때 좋다
    - 서버에서 클라로 데이터 내려줄때, enum 클래스로 내려주면 좋다. 클라에서도 enum을 알고 있다면!

<br/><br/>

# 정리

### 데코레이터 패턴 (Decorator Pattern)

- 맨 처음 수많은 상속 구상 클래스를 만드는 대신에 첨가물을 어떤 식으로 분리할까 고민했을 때, 인터페이스를 떠올렸다. 첨가물 인터페이스를 만들고 구상 클래스는 list형식으로 첨가물들을 가지고 있으면 되지 않을까. 그리고 동적으로 추가, 삭제할 수 있게.
- 하지만 이렇게 되면 기존 음료 클래스가 첨가물에 관련된 코드도 가지고 있어야 하고, 첨가물에 대한 내용 수정을 음료 클래스 내부에서 해야 한다. 썩 깔끔하게 분리된 느낌이 아닌것이다.
    
    ```java
    public class DarkRoast extends Beverage {
    	ArrayList<Condiment> condimentsList;
    
    	public void addCondiment(Condiment condiment){
    	}
    
    	public void removeCondiment(Condiment condiment){
    	}
    
    	@override
    	public String getDescription() {
    		// 첨가물 설명을 덧붙이는 방식을 음료 클래스에서 구현해야 함
    		for(condiment:condimentList){
    			this.description += ", " + condiment.getDescription();	
    		}
    	}
    }
    ```
    
- 데코레이터라는 말이 잘 와닿지 않았는데, 개인적으로는 ‘어부바’라고 생각하니까 좀더 이해가 되기도 하고.
- 슈퍼 클래스 ‘음료’ 가 존재한다. 속성으로 ‘설명’을, 함수로 ‘가격 반환’ 과 ‘설명 반환’을 가진다.
- 음료를 상속한 음료 구상 클래스들이 있다.
- 음료를 상속한 ‘첨가물’ 클래스를 만든다.
    - 음료 객체를 가지고 있다. (=구성) 생성자에서 음료 객체를 받아야만한다. 첨가물 객체는 혼자 설 수 없는 구조.
    - 구체적인 코드 구현을 상속해야 할 필요는 없고, 음료 객체에 마구 첨가물이 더해진 다음에도 그 객체는 음료 객체로 일할 수 있어야 하므로 형식을 맞춰준다. ( = 음료 클래스의 모든 메소드를 추상 메소드화 해서 가지고 있는다 )
- 첨가물을 더하고 싶다면 음료 객체를 첨가물 객체로 덮어쓰면 된다.
    
    ```java
    Beverage darkRoast = new DarkRoast();
    
    darkRoast = new Whip(darkRoast);
    ```
    
- 여기에서 darkRoast 의 getDescription() 을 실행했을 때 ‘다크로스트’ 가 아니라 ‘다크로스트, 휘핑’ 이렇게 나와야 한다.
- 이런 추가작업을 하기 위해서 첨가물 클래스가 음료 객체를 가지고 있던 것이고, 생성자에서 파라미터로 받아주는 것이다.
- 휘핑 객체의 getDescription 함수는 다음과 같다
    
    ```java
    public class DarkRoast implements CondimentDecorator {
    	Beverage beverage
    
    	@override
    	public void getDescription(){
    		return beverage.getDescription + ", 휘핑" ; 
    	} 
    }
    ```
    
- 상속받은 변수를 조합해서 만드는 게 아니라 구성요소인 객체의 함수를 불러오고 내가 원하는 방식으로 추가 작업을 더해서 리턴해준다. 아주 신기한 방식이다.
- 데코레이터 패턴의 특성
    - 데코레이터 놈들은 혼자 걸어다닐 생각이 없다. 혼자 인스턴스화 ㄴㄴ
    - 뭘 좀 덧붙였다고 다른 무언가가 되지는 않는다. 원래의 함수, 변수 모두 그대로
    - 본 객체와 데코레이터의 수정, 확장은 별도로 이루어질 수 있다.
    - 동적으로 데코레이터를 마구 추가할 수 있다.
    - 본 객체 자체를 가지고 추가 작업을 해야한다면 썩 어울리는 패턴이 아니다. 이것저것 붙여서 내보내기 위한 패턴이므로. 아무것도 붙이지 않은 깨끗한 객체를 원한다면 다시 생각해볼것
    - 마지막 데코레이터가 중간 데코레이터의 변수를 가져와서 무슨 작업을 하고.. 그런 작업또한 이 패턴의 의도와 어긋남. 데코레이터는 그저 본 객체에 챡 달라붙을 뿐,, 서로를 인식할 이유는 없다.